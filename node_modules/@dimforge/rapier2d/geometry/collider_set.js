import { RawColliderSet } from "../raw";
import { RotationOps, VectorOps } from '../math';
import { Collider } from './collider';
/**
 * A set of rigid bodies that can be handled by a physics pipeline.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
var ColliderSet = /** @class */ (function () {
    function ColliderSet(raw) {
        this.raw = raw || new RawColliderSet();
    }
    /**
     * Release the WASM memory occupied by this collider set.
     */
    ColliderSet.prototype.free = function () {
        this.raw.free();
        this.raw = undefined;
    };
    /**
     * Creates a new collider and return its integer handle.
     *
     * @param bodies - The set of bodies where the collider's parent can be found.
     * @param desc - The collider's description.
     * @param parentHandle - The inteer handle of the rigid-body this collider is attached to.
     */
    ColliderSet.prototype.createCollider = function (bodies, desc, parentHandle) {
        var hasParent = parentHandle != undefined && parentHandle != null;
        if (hasParent && isNaN(parentHandle))
            throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
        var rawShape = desc.shape.intoRaw();
        var rawTra = VectorOps.intoRaw(desc.translation);
        var rawRot = RotationOps.intoRaw(desc.rotation);
        var rawCom = VectorOps.intoRaw(desc.centerOfMass);
        var handle = this.raw.createCollider(rawShape, rawTra, rawRot, desc.useMassProps, desc.mass, rawCom, 
        // #if DIM2
        desc.principalAngularInertia, 
        // #endif
        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, hasParent, hasParent ? parentHandle : 0, bodies.raw);
        rawShape.free();
        rawTra.free();
        rawRot.free();
        rawCom.free();
        return handle;
    };
    /**
     * Remove a collider from this set.
     *
     * @param handle - The integer handle of the collider to remove.
     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.
     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.
     */
    ColliderSet.prototype.remove = function (handle, islands, bodies, wakeUp) {
        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);
    };
    /**
     * Gets the rigid-body with the given handle.
     *
     * @param handle - The handle of the rigid-body to retrieve.
     */
    ColliderSet.prototype.get = function (handle) {
        if (this.raw.contains(handle)) {
            return new Collider(this.raw, handle);
        }
        else {
            return null;
        }
    };
    /**
     * The number of colliders on this set.
     */
    ColliderSet.prototype.len = function () {
        return this.raw.len();
    };
    /**
     * Does this set contain a collider with the given handle?
     *
     * @param handle - The collider handle to check.
     */
    ColliderSet.prototype.contains = function (handle) {
        return this.raw.contains(handle);
    };
    /**
     * Applies the given closure to each collider contained by this set.
     *
     * @param f - The closure to apply.
     */
    ColliderSet.prototype.forEachCollider = function (f) {
        var _this = this;
        this.forEachColliderHandle(function (handle) {
            f(new Collider(_this.raw, handle));
        });
    };
    /**
     * Applies the given closure to the handles of each collider contained by this set.
     *
     * @param f - The closure to apply.
     */
    ColliderSet.prototype.forEachColliderHandle = function (f) {
        this.raw.forEachColliderHandle(f);
    };
    return ColliderSet;
}());
export { ColliderSet };
//# sourceMappingURL=collider_set.js.map